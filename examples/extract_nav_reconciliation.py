#!/usr/bin/env python3
"""Extract NAV reconciliation components from XBRL files.

NAV(t) = NAV(t-1)
       - ManagementFee
       + NetInterest
       + NetRealizedGains
       + NetUnrealizedGains
       + NetFXGains
       - OtherFeesExpenses
       + CapitalCalls
       - Distributions

This script supports issuer-specific XBRL concept mappings loaded from
output/{ticker}/xbrl_mapping.json files generated by analyze_xbrl_concepts.py.
"""

import json
import re
import csv
from pathlib import Path
from xml.etree import ElementTree as ET

# Namespaces - both BMV and CNBV
NS_BMV = "http://www.bmv.com.mx/2015-06-30/ccd"
NS_CNBV = "http://www.cnbv.gob.mx/2015-06-30/ccd"
NS_IFRS = "http://xbrl.ifrs.org/taxonomy/2014-03-05/ifrs-full"

# Namespace prefix to URI mapping (for loading from JSON)
NAMESPACE_MAP = {
    'mx_ccd': NS_CNBV,
    'mx_bmv': NS_BMV,
    'ifrs': NS_IFRS,
}

# =============================================================================
# CONCEPT MAPPINGS BY FINANCIAL STATEMENT
# =============================================================================
# Each concept is classified by its source statement:
#   - BALANCE SHEET: Point-in-time values (instant context), non-cumulative
#   - P&L (Income Statement): Period values (quarterly context), shows flow for period
#   - CASH FLOW: Period values (often YTD context), shows cash movements
#
# For NAV reconciliation:
#   - Balance sheet items: Use instant context, calculate delta between periods
#   - P&L items: Use quarterly context (~90 days), value is the period flow
#   - Cash flow items: Often YTD, need to calculate quarterly delta
# =============================================================================

# Concept mappings: (namespace, local_name) -> (category, sign)
# sign: 1 = positive contribution
CONCEPT_MAP = {
    # =========================================================================
    # BALANCE SHEET ITEMS (instant context, point-in-time)
    # =========================================================================
    # NAV (Equity) - Total fund value at period end
    (NS_IFRS, 'Equity'): ('nav', 1),
    # IssuedCapital - Used to derive capital calls from period-over-period delta
    (NS_IFRS, 'IssuedCapital'): ('issued_capital', 1),

    # =========================================================================
    # P&L ITEMS - INCOME (quarterly context, period flow)
    # =========================================================================
    # Interest Income
    (NS_BMV, 'InterestIncome'): ('interest_income', 1),
    (NS_CNBV, 'InterestIncome'): ('interest_income', 1),
    (NS_BMV, 'FinancialIncome'): ('interest_income', 1),
    (NS_CNBV, 'FinancialIncome'): ('interest_income', 1),
    # IFRS interest income - note: FinanceIncome often overlaps with FX gains
    (NS_IFRS, 'RevenueFromInterest'): ('interest_income', 1),

    # Realized Gains (from dispositions and dividend income)
    (NS_BMV, 'RealizedGainOfAssetsDesignatedAtFairValue'): ('realized_gains', 1),
    (NS_CNBV, 'RealizedGainOfAssetsDesignatedAtFairValue'): ('realized_gains', 1),
    (NS_BMV, 'SaleOfProperty'): ('realized_gains', 1),
    (NS_CNBV, 'SaleOfProperty'): ('realized_gains', 1),
    # Dividend income (P&L) - actual income from dividends received
    (NS_IFRS, 'RevenueFromDividends'): ('realized_gains', 1),

    # Unrealized Gains (fair value changes)
    (NS_BMV, 'GainOnValuationOfFinancialInstruments'): ('unrealized_gains', 1),
    (NS_CNBV, 'GainOnValuationOfFinancialInstruments'): ('unrealized_gains', 1),
    (NS_BMV, 'IncomeFromChangeInFairValueOfSharesCertificatesInvestmentProperty'): ('unrealized_gains', 1),
    (NS_CNBV, 'IncomeFromChangeInFairValueOfSharesCertificatesInvestmentProperty'): ('unrealized_gains', 1),
    (NS_BMV, 'GainOnValuationOfInvestmentsHeldToMaturityPreserved'): ('unrealized_gains', 1),
    (NS_CNBV, 'GainOnValuationOfInvestmentsHeldToMaturityPreserved'): ('unrealized_gains', 1),
    (NS_BMV, 'IncomeFromRevaluationOfInvestmentCompanyPromoted'): ('unrealized_gains', 1),
    (NS_CNBV, 'IncomeFromRevaluationOfInvestmentCompanyPromoted'): ('unrealized_gains', 1),
    (NS_BMV, 'GainOnChangeInFairValueOfFinancialInstruments'): ('unrealized_gains', 1),
    (NS_CNBV, 'GainOnChangeInFairValueOfFinancialInstruments'): ('unrealized_gains', 1),

    # FX Gains (currency translation gains)
    (NS_BMV, 'ForeignExchangeIncomeFromInvestments'): ('fx_gains', 1),
    (NS_CNBV, 'ForeignExchangeIncomeFromInvestments'): ('fx_gains', 1),
    (NS_BMV, 'GainOnForeignExchange'): ('fx_gains', 1),
    (NS_CNBV, 'GainOnForeignExchange'): ('fx_gains', 1),

    # =========================================================================
    # P&L ITEMS - EXPENSES (quarterly context, period flow)
    # =========================================================================
    # Management Fee
    (NS_BMV, 'ManagementFee'): ('management_fee', 1),
    (NS_CNBV, 'ManagementFee'): ('management_fee', 1),
    (NS_BMV, 'FeesCostsAndExpensesOfTheAdministratorOrOperator'): ('management_fee', 1),
    (NS_CNBV, 'FeesCostsAndExpensesOfTheAdministratorOrOperator'): ('management_fee', 1),

    # Interest Expense
    (NS_BMV, 'InterestExpense'): ('interest_expense', 1),
    (NS_CNBV, 'InterestExpense'): ('interest_expense', 1),
    (NS_BMV, 'AccruedInterestExpense'): ('interest_expense', 1),
    (NS_CNBV, 'AccruedInterestExpense'): ('interest_expense', 1),
    (NS_BMV, 'FinancialExpenses'): ('interest_expense', 1),
    (NS_CNBV, 'FinancialExpenses'): ('interest_expense', 1),

    # Unrealized Losses
    (NS_BMV, 'LossOnChangesInFairValueOfFinancialInstruments'): ('unrealized_losses', 1),
    (NS_CNBV, 'LossOnChangesInFairValueOfFinancialInstruments'): ('unrealized_losses', 1),
    (NS_BMV, 'LossOnValuationOfInvestmentsHeldToMaturityPreserved'): ('unrealized_losses', 1),
    (NS_CNBV, 'LossOnValuationOfInvestmentsHeldToMaturityPreserved'): ('unrealized_losses', 1),

    # FX Losses
    (NS_BMV, 'ForeignExchangeLoss'): ('fx_losses', 1),
    (NS_CNBV, 'ForeignExchangeLoss'): ('fx_losses', 1),

    # Other Operating Expenses
    (NS_BMV, 'ProfessionalFees'): ('other_expenses', 1),
    (NS_CNBV, 'ProfessionalFees'): ('other_expenses', 1),
    (NS_BMV, 'InsurancesAndGuarantees'): ('other_expenses', 1),
    (NS_CNBV, 'InsurancesAndGuarantees'): ('other_expenses', 1),
    (NS_BMV, 'FeesAndRights'): ('other_expenses', 1),
    (NS_CNBV, 'FeesAndRights'): ('other_expenses', 1),
    (NS_BMV, 'MaintenanceCosts'): ('other_expenses', 1),
    (NS_CNBV, 'MaintenanceCosts'): ('other_expenses', 1),
    (NS_BMV, 'OtherAdministrativeExpenses'): ('other_expenses', 1),
    (NS_CNBV, 'OtherAdministrativeExpenses'): ('other_expenses', 1),
    (NS_BMV, 'Advertising'): ('other_expenses', 1),
    (NS_CNBV, 'Advertising'): ('other_expenses', 1),
    (NS_BMV, 'Taxes'): ('other_expenses', 1),
    (NS_CNBV, 'Taxes'): ('other_expenses', 1),
    (NS_BMV, 'TaxCaused'): ('other_expenses', 1),
    (NS_CNBV, 'TaxCaused'): ('other_expenses', 1),
    (NS_BMV, 'DeferredTax'): ('other_expenses', 1),
    (NS_CNBV, 'DeferredTax'): ('other_expenses', 1),
    (NS_BMV, 'ComissionRepresentativeServices'): ('other_expenses', 1),
    (NS_CNBV, 'ComissionRepresentativeServices'): ('other_expenses', 1),

    # =========================================================================
    # CASH FLOW ITEMS (often YTD context, need quarterly delta)
    # =========================================================================
    # Capital Calls - cash inflows from investors (financing activities)
    # Note: We primarily derive this from IssuedCapital balance sheet delta,
    # but this captures any explicit cash flow reporting
    (NS_BMV, 'IssueAndPlacementOfStockCertificates'): ('capital_calls', 1),
    (NS_CNBV, 'IssueAndPlacementOfStockCertificates'): ('capital_calls', 1),

    # Distributions - cash outflows to investors (financing activities)
    # Note: DividendsPaid is the total, DividendsPaidClassifiedAsFinancingActivities is the breakdown
    # Only use one to avoid double counting
    (NS_IFRS, 'DividendsPaidClassifiedAsFinancingActivities'): ('distributions', 1),

    # =========================================================================
    # EXCLUDED ITEMS - Not part of NAV reconciliation P&L
    # =========================================================================
    # DividendsReceivedClassifiedAsInvestingActivities - This is a CASH FLOW
    # statement item showing cash received from portfolio investments.
    # For CKDs/PE funds, this represents return of capital (reduces investment
    # carrying value), NOT income that affects retained earnings.
    # Do NOT include in realized_gains.
}

# Build reverse lookup: full tag -> (category, sign)
DEFAULT_TAG_MAP = {f"{{{ns}}}{name}": (cat, sign) for (ns, name), (cat, sign) in CONCEPT_MAP.items()}


def load_issuer_mapping(ticker: str) -> dict | None:
    """Load issuer-specific XBRL mapping from JSON file."""
    mapping_path = Path(f'output/{ticker}/xbrl_mapping.json')
    if not mapping_path.exists():
        return None

    try:
        with open(mapping_path) as f:
            data = json.load(f)
        return data.get('mappings', {})
    except (json.JSONDecodeError, IOError) as e:
        print(f"Warning: Could not load mapping for {ticker}: {e}")
        return None


def build_tag_map(ticker: str) -> dict:
    """Build TAG_MAP for an issuer using their specific mapping or defaults.

    Returns a dict mapping full XML tag -> (category, sign)
    """
    mapping_path = Path(f'output/{ticker}/xbrl_mapping.json')
    if not mapping_path.exists():
        print(f"  Using default concept mappings for {ticker}")
        return DEFAULT_TAG_MAP

    try:
        with open(mapping_path) as f:
            data = json.load(f)
        issuer_mapping = data.get('mappings', {})
        candidates = data.get('candidates', {})
    except (json.JSONDecodeError, IOError) as e:
        print(f"Warning: Could not load mapping for {ticker}: {e}")
        return DEFAULT_TAG_MAP

    print(f"  Using issuer-specific mappings for {ticker}")
    tag_map = {}

    # Categories we need for NAV reconciliation
    nav_categories = [
        'nav', 'issued_capital', 'management_fee',
        'interest_income', 'interest_expense',
        'realized_gains', 'unrealized_gains', 'unrealized_losses',
        'fx_gains', 'fx_losses', 'other_expenses',
        'capital_calls', 'distributions'
    ]

    for category in nav_categories:
        if category in issuer_mapping:
            mapping = issuer_mapping[category]
            namespace = mapping.get('namespace', '')
            local_name = mapping.get('local_name', '')
            sign = mapping.get('sign', 1)

            if namespace and local_name:
                full_tag = f"{{{namespace}}}{local_name}"
                tag_map[full_tag] = (category, sign)

            # Also add alternatives if they exist
            for alt in mapping.get('alternatives', []):
                # Parse alternative format like "ifrs:FinanceCosts" or "mx_ccd:AccruedInterestExpense"
                if ':' in alt:
                    prefix, name = alt.split(':', 1)
                    ns = NAMESPACE_MAP.get(prefix, '')
                    if ns:
                        alt_tag = f"{{{ns}}}{name}"
                        # Don't overwrite primary mapping
                        if alt_tag not in tag_map:
                            tag_map[alt_tag] = (category, sign)

        # Also add concepts from candidates lists for this category
        if category in candidates:
            for cand in candidates[category]:
                namespace = cand.get('namespace', '')
                local_name = cand.get('local_name', '')
                if namespace and local_name:
                    full_tag = f"{{{namespace}}}{local_name}"
                    if full_tag not in tag_map:
                        tag_map[full_tag] = (category, 1)

        # Fall back to default mappings for this category if nothing found
        if not any(cat == category for _, (cat, _) in tag_map.items()):
            for full_tag, (cat, sign) in DEFAULT_TAG_MAP.items():
                if cat == category:
                    tag_map[full_tag] = (cat, sign)

    # Add high-value uncategorized concepts to appropriate categories based on naming
    uncategorized = candidates.get('uncategorized', [])
    for cand in uncategorized:
        local_name = cand.get('local_name', '')
        namespace = cand.get('namespace', '')
        non_zero_count = cand.get('non_zero_count', 0)
        avg_val = abs(cand.get('avg', 0))

        # Only consider concepts with significant occurrence
        if non_zero_count < 10 or avg_val < 100_000:
            continue

        full_tag = f"{{{namespace}}}{local_name}"
        if full_tag in tag_map:
            continue

        # Map based on concept name patterns
        name_lower = local_name.lower()
        if 'financeincome' in name_lower or 'otherincome' in name_lower:
            tag_map[full_tag] = ('interest_income', 1)
        elif 'financecost' in name_lower and 'adjustments' not in name_lower:
            tag_map[full_tag] = ('interest_expense', 1)
        elif 'feesandrights' in name_lower:
            tag_map[full_tag] = ('other_expenses', 1)
        elif 'netcontributionofholders' in name_lower:
            # This is a YTD capital contributions adjustment - skip it
            pass

    return tag_map


def parse_quarterly_filename(filename: str, ticker: str) -> dict | None:
    """Extract quarter info from filename."""
    # Patterns with date prefix (8 digits)
    patterns_with_date = [
        rf'(\d{{8}})_ReporteTrimestral_(\d)D?T_(\d{{4}})_{ticker}',
        rf'(\d{{8}})_.*ReporteTrimestral_{ticker}[^_]*_(\d{{4}})_(\d+D?)_',
        rf'(\d{{8}})_Información trimestral (\d)D?-(\d{{4}})',
        rf'(\d{{8}})_Información financiera (\d)D? - (\d{{4}})',
    ]
    for pattern in patterns_with_date:
        match = re.search(pattern, filename)
        if match:
            groups = match.groups()
            file_date, q, year = groups
            if len(q) == 4 and q.isdigit():
                year, q = q, year
            quarter = int(str(q).replace('D', ''))
            is_def = 'D' in str(q) or 'DT' in filename
            return {
                'file_date': file_date,
                'quarter': quarter,
                'year': int(year),
                'period': f"{year}Q{quarter}{'D' if is_def else ''}",
            }

    # Patterns WITHOUT date prefix - common format: ReporteTrimestral_1T_2024_TICKER_...
    patterns_no_date = [
        # ReporteTrimestral_1T_2024_TICKER_...
        rf'ReporteTrimestral_(\d)D?T_(\d{{4}})_\w+_.*?(\d+)\.xbrl$',
        # ReporteTrimestral_TICKER_2024_1_...
        rf'ReporteTrimestral_\w+_(\d{{4}})_(\d)D?_.*?(\d+)\.xbrl$',
        # Just timestamp: 3831_1658963800664.xbrl - skip these, need to parse XBRL content
    ]
    for pattern in patterns_no_date:
        match = re.search(pattern, filename)
        if match:
            groups = match.groups()
            if len(groups) >= 3:
                q, year, timestamp = groups[0], groups[1], groups[2]
                # Handle swapped order
                if len(q) == 4 and q.isdigit():
                    year, q = q, year
                quarter = int(str(q).replace('D', ''))
                is_def = 'D' in str(q) or 'DT' in filename
                return {
                    'file_date': timestamp[:8] if len(timestamp) >= 8 else timestamp,
                    'quarter': quarter,
                    'year': int(year),
                    'period': f"{year}Q{quarter}{'D' if is_def else ''}",
                }

    return None


def extract_values(xbrl_path: Path, tag_map: dict) -> dict:
    """Extract NAV reconciliation values from an XBRL file.

    Args:
        xbrl_path: Path to the XBRL file
        tag_map: Dict mapping full XML tags to (category, sign) tuples
    """
    from datetime import datetime

    try:
        tree = ET.parse(xbrl_path)
        root = tree.getroot()
    except ET.ParseError as e:
        print(f"Error parsing {xbrl_path.name}: {e}")
        return {}

    # Find contexts - need to match current period (not prior year comparatives)
    instant_contexts = set()
    current_quarterly_contexts = set()
    balance_date = None
    balance_date_dt = None

    # First pass: find the balance date from instant contexts
    for ctx in root.findall('.//{http://www.xbrl.org/2003/instance}context'):
        if ctx.find('.//{http://www.xbrl.org/2003/instance}scenario') is not None:
            continue
        period = ctx.find('.//{http://www.xbrl.org/2003/instance}period')
        if period is not None:
            instant = period.find('.//{http://www.xbrl.org/2003/instance}instant')
            if instant is not None:
                instant_contexts.add(ctx.get('id'))
                # Get the most recent balance date (current period)
                try:
                    dt = datetime.strptime(instant.text, '%Y-%m-%d')
                    if balance_date_dt is None or dt > balance_date_dt:
                        balance_date_dt = dt
                        balance_date = instant.text
                except ValueError:
                    pass

    # Second pass: find contexts that END on the balance date
    current_ytd_contexts = set()  # YTD contexts ending on balance date (for cash flows)

    for ctx in root.findall('.//{http://www.xbrl.org/2003/instance}context'):
        ctx_id = ctx.get('id')
        if ctx.find('.//{http://www.xbrl.org/2003/instance}scenario') is not None:
            continue
        period = ctx.find('.//{http://www.xbrl.org/2003/instance}period')
        if period is not None:
            instant = period.find('.//{http://www.xbrl.org/2003/instance}instant')
            if instant is None:
                # Duration context
                start = period.find('.//{http://www.xbrl.org/2003/instance}startDate')
                end = period.find('.//{http://www.xbrl.org/2003/instance}endDate')
                if start is not None and end is not None:
                    try:
                        start_dt = datetime.strptime(start.text, '%Y-%m-%d')
                        end_dt = datetime.strptime(end.text, '%Y-%m-%d')
                        days = (end_dt - start_dt).days
                        # Must end on balance date
                        if end.text == balance_date:
                            # Quarterly = ~90 days
                            if 60 <= days <= 120:
                                current_quarterly_contexts.add(ctx_id)
                            # YTD or longer
                            else:
                                current_ytd_contexts.add(ctx_id)
                    except ValueError:
                        pass

    period_contexts = current_quarterly_contexts
    ytd_contexts = current_ytd_contexts

    # Categories and their context types:
    # - instant: balance sheet items
    # - quarterly: income statement items (P&L)
    # - ytd: cash flow items (capital calls, distributions)
    instant_categories = {'nav', 'issued_capital'}
    ytd_categories = {'capital_calls', 'distributions'}  # Cash flow items are YTD

    # Initialize results
    data = {
        'balance_date': balance_date,
        'nav': None,
        'issued_capital': None,  # Balance sheet item - used to derive capital calls
        'management_fee': 0,
        'interest_income': 0,
        'interest_expense': 0,
        'realized_gains': 0,
        'unrealized_gains': 0,
        'unrealized_losses': 0,
        'fx_gains': 0,
        'fx_losses': 0,
        'other_expenses': 0,
        'capital_calls_ytd': 0,  # YTD values - will compute delta later
        'distributions_ytd': 0,
        'capital_calls': 0,
        'distributions': 0,
    }

    # Extract values
    for elem in root.iter():
        if elem.tag not in tag_map:
            continue

        category, sign = tag_map[elem.tag]
        ctx_ref = elem.get('contextRef')

        # Check context type based on category
        if category in instant_categories:
            if ctx_ref not in instant_contexts:
                continue
        elif category in ytd_categories:
            # For cash flow items, prefer YTD contexts, fallback to quarterly
            if ctx_ref in ytd_contexts:
                category = category + '_ytd'  # Mark as YTD
            elif ctx_ref in period_contexts:
                pass  # Use quarterly if available
            else:
                continue
        else:
            # Income statement items - use quarterly context
            if ctx_ref not in period_contexts:
                continue

        try:
            value = int(elem.text) if elem.text else 0
            if category == 'nav':
                if data['nav'] is None:
                    data['nav'] = value
            elif category == 'issued_capital':
                if data['issued_capital'] is None:
                    data['issued_capital'] = value
            else:
                data[category] += value * sign
        except (ValueError, TypeError):
            pass

    # Calculate derived fields
    data['net_interest'] = data['interest_income'] - data['interest_expense']
    data['net_unrealized'] = data['unrealized_gains'] - data['unrealized_losses']
    data['net_fx'] = data['fx_gains'] - data['fx_losses']

    return data


def process_issuer(ticker: str, xbrl_dir: Path, output_path: Path):
    """Process all quarterly files for an issuer."""
    quarterly_files = []
    for f in xbrl_dir.glob('*.xbrl'):
        info = parse_quarterly_filename(f.name, ticker)
        if info:
            info['path'] = f
            quarterly_files.append(info)

    if not quarterly_files:
        print(f"No quarterly files found for {ticker}")
        return []

    quarterly_files.sort(key=lambda x: (x['year'], x['quarter'], x.get('file_date', '')))
    print(f"Found {len(quarterly_files)} quarterly files for {ticker}")

    # Build issuer-specific TAG_MAP
    tag_map = build_tag_map(ticker)

    results = []
    for qf in quarterly_files:
        data = extract_values(qf['path'], tag_map)
        if data and data.get('nav'):
            row = {
                'ticker': ticker,
                'period': qf['period'],
                'year': qf['year'],
                'quarter': qf['quarter'],
                'file_date': qf['file_date'],
                **data
            }
            results.append(row)

    # Deduplicate (keep latest file_date per period)
    seen = {}
    for r in results:
        key = (r['year'], r['quarter'])
        if key not in seen or r['file_date'] > seen[key]['file_date']:
            seen[key] = r

    results = sorted(seen.values(), key=lambda x: (x['year'], x['quarter']))

    # Calculate NAV changes and check reconciliation
    # Compute capital calls from IssuedCapital delta (more reliable than cash flow items)
    for i, r in enumerate(results):
        if i == 0:
            r['nav_prior'] = None
            r['nav_change'] = None
            r['calculated_change'] = None
            r['reconciliation_diff'] = None
            # For first period, can't compute capital calls from delta
            # Use YTD if available, otherwise leave as 0
            if r['capital_calls'] == 0 and r['capital_calls_ytd'] != 0:
                r['capital_calls'] = r['capital_calls_ytd']
            if r['distributions'] == 0 and r['distributions_ytd'] != 0:
                r['distributions'] = r['distributions_ytd']
        else:
            prior = results[i-1]
            r['nav_prior'] = prior['nav']
            r['nav_change'] = r['nav'] - prior['nav']

            # Compute capital calls and distributions from IssuedCapital delta
            # This is more reliable than cash flow line items which may double-count
            # IssuedCapital delta directly reflects capital movements:
            # - Increase = capital calls (new investor contributions)
            # - Decrease = distributions/redemptions (capital returned to investors)
            issued_cap = r.get('issued_capital') or 0
            issued_cap_prior = prior.get('issued_capital') or 0
            issued_cap_delta = issued_cap - issued_cap_prior

            if issued_cap_delta > 0:
                r['capital_calls'] = issued_cap_delta
                r['distributions'] = 0  # Reset any extracted CF value to avoid double counting
            elif issued_cap_delta < 0:
                r['capital_calls'] = 0
                r['distributions'] = abs(issued_cap_delta)  # Override with BS delta
            else:
                # No change in issued capital - keep any extracted values
                pass

            # Expected change = -MgtFee + NetInterest + RealizedGains + NetUnrealized + NetFX - OtherExp + CapCalls - Dist
            r['calculated_change'] = (
                -r['management_fee']
                + r['net_interest']
                + r['realized_gains']
                + r['net_unrealized']
                + r['net_fx']
                - r['other_expenses']
                + r['capital_calls']
                - r['distributions']
            )
            r['reconciliation_diff'] = r['nav_change'] - r['calculated_change']

    # Write CSV
    fieldnames = [
        'ticker', 'period', 'year', 'quarter', 'balance_date',
        'nav', 'nav_prior', 'nav_change',
        'management_fee',
        'interest_income', 'interest_expense', 'net_interest',
        'realized_gains',
        'unrealized_gains', 'unrealized_losses', 'net_unrealized',
        'fx_gains', 'fx_losses', 'net_fx',
        'other_expenses',
        'capital_calls', 'distributions',
        'calculated_change', 'reconciliation_diff'
    ]

    with open(output_path, 'w', newline='') as f:
        writer = csv.DictWriter(f, fieldnames=fieldnames, extrasaction='ignore')
        writer.writeheader()
        writer.writerows(results)

    print(f"Written {len(results)} quarters to {output_path}")

    # Print summary
    print(f"\n{'Period':<10} {'NAV':>15} {'Change':>12} {'Calculated':>12} {'Diff':>12}")
    print("=" * 65)
    for r in results:
        nav = f"{r['nav']:,.0f}" if r['nav'] else 'N/A'
        chg = f"{r['nav_change']:,.0f}" if r['nav_change'] is not None else 'N/A'
        calc = f"{r['calculated_change']:,.0f}" if r['calculated_change'] is not None else 'N/A'
        diff = f"{r['reconciliation_diff']:,.0f}" if r['reconciliation_diff'] is not None else 'N/A'
        print(f"{r['period']:<10} {nav:>15} {chg:>12} {calc:>12} {diff:>12}")

    return results


def main():
    # Top 10 CERPIs by assets
    issuers = [
        ('AYLLUPI', Path('output/AYLLUPI/xbrls')),
        ('CAPGLPI', Path('output/CAPGLPI/xbrls')),
        ('GLOB1PI', Path('output/GLOB1PI/xbrls')),
        ('LOCKXPI', Path('output/LOCKXPI/xbrls')),
        ('BLKPEPI', Path('output/BLKPEPI/xbrls')),
        ('QTZALPI', Path('output/QTZALPI/xbrls')),
        ('SVPI', Path('output/SVPI/xbrls')),
        ('HV2PI', Path('output/HV2PI/xbrls')),
        ('CAPI', Path('output/CAPI/xbrls')),
        ('KANANPI', Path('output/KANANPI/xbrls')),
    ]

    all_results = []
    for ticker, xbrl_dir in issuers:
        if xbrl_dir.exists():
            print(f"\n{'='*70}")
            print(f"Processing {ticker}")
            print('='*70)
            output_path = xbrl_dir.parent / 'nav_reconciliation.csv'
            results = process_issuer(ticker, xbrl_dir, output_path)
            if results:
                all_results.extend(results)

    # Combined file
    if all_results:
        combined_path = Path('output/combined_nav_reconciliation.csv')
        fieldnames = [
            'ticker', 'period', 'year', 'quarter', 'balance_date',
            'nav', 'nav_prior', 'nav_change',
            'management_fee',
            'interest_income', 'interest_expense', 'net_interest',
            'realized_gains',
            'unrealized_gains', 'unrealized_losses', 'net_unrealized',
            'fx_gains', 'fx_losses', 'net_fx',
            'other_expenses',
            'capital_calls', 'distributions',
            'calculated_change', 'reconciliation_diff'
        ]
        with open(combined_path, 'w', newline='') as f:
            writer = csv.DictWriter(f, fieldnames=fieldnames, extrasaction='ignore')
            writer.writeheader()
            writer.writerows(sorted(all_results, key=lambda x: (x['ticker'], x['year'], x['quarter'])))
        print(f"\nCombined data written to {combined_path}")


if __name__ == '__main__':
    main()
